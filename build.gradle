buildscript {
  repositories {
    jcenter()
  }

  dependencies {
    classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.1'
    classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.1"
    classpath "com.readytalk.gradle:gradle-readytalk-ci:0.2.3"
  }
}

apply plugin: 'native-component'
apply plugin: 'ivy-publish'
apply plugin: 'java'
apply plugin: "com.jfrog.bintray"
apply plugin: "com.jfrog.artifactory"
apply plugin: "com.readytalk.ci"

enum SupportedOS implements OperatingSystem {
  LINUX, WINDOWS, DARWIN;

  public static final SupportedOS CURRENT;

  static {
    String p = System.properties['os.name']
    switch(p.replaceAll(' ', '').toLowerCase()) {
      case ~/.*linux.*/:  CURRENT = LINUX; break;
      case ~/.*darwin.*/: CURRENT = DARWIN; break;
      case ~/.*osx.*/:    CURRENT = DARWIN; break;
      case ~/.*win.*/:    CURRENT = WINDOWS; break;
      default:
        String m = "SupportedOS: unrecognized platform: ${p}"
        println(m)
        throw new IllegalArgumentException(m)
    }
  }

  public String getName() {
    return toString().toLowerCase()
  }

  public String  getDisplayName() {
    return getName()
  }
  public boolean isCurrent() { return this == CURRENT }
  public boolean isFreeBSD() { return false }
  public boolean isLinux() { return this == LINUX }
  public boolean isMacOsX() { return this == DARWIN }
  public boolean isSolaris() { return false }
  public boolean isWindows() { return this == WINDOWS }

}

public String adjustArch(String arch) {
  switch(arch) {
    case ~/.*64.*/: return 'x86_64'
    default:        return 'i386'
  }
}

ext {
  currentPlatform = SupportedOS.CURRENT.getName()
  currentArch = adjustArch(System.properties['os.arch'])
  currentPlatformArch = "${currentPlatform}-${currentArch}"

  platform = project.hasProperty('platform') ? platform : currentPlatform
  arch = project.hasProperty('arch') ? arch : currentArch
  platformArch = "${platform}-${arch}"

  java_home = System.properties.'java.home'
  if(java_home.endsWith("/jre")) {
    java_home = java_home.substring(0, java_home.length() - "/jre".length())
  }
  java_home = java_home

  libDir = "${buildDir}/lib"

  isMaster = buildEnv.travisBranch == "master" && buildEnv.travisPullRequest == 'false'
  isReleaseBranch = buildEnv.travisBranch ==~ /release_\d+\.\d+\.\d+/ && buildEnv.travisPullRequest == 'false'
  isReleaseTag = buildEnv.travisTag ==~ /v\d+\.\d+\.\d+/
}

logger.info "master: $isMaster"
logger.info "releasebranch: $isReleaseBranch"
logger.info "releasetag: $isReleaseTag"

if (!isReleaseTag) {
  version = version + '-SNAPSHOT'
}

repositories {
  ivy {
    name "local"
    url "${System.env.HOME}/.ivy2/local"
    layout 'maven'
  }

  ivy {
     name "jcenter"
     url "http://oss.jfrog.org/artifactory/oss-release-local"
     layout 'maven'
  }

  ivy {
    name "jcenter-snapshots"
    url "http://oss.jfrog.org/artifactory/oss-snapshot-local"
    layout 'maven'
  }
}

configurations {
  create('windows-i386')
  create('windows-x86_64')
}

dependencies {
  'windows-i386' "com.readytalk:win32:1.0.0-SNAPSHOT"
  'windows-x86_64' "com.readytalk:win64:1.0.0-SNAPSHOT"
}

model {
  platforms {
    create(platformArch) {
      operatingSystem SupportedOS.valueOf(platform.toUpperCase())
      architecture "${arch}"
    }
  }

  tasks {
    platforms.each { platform ->
      if(platform.operatingSystem.name == "windows") {
        def artifactName = platform.architecture.name == "i386" ? 'win32' : 'win64'

        task "extract${platform.name}"(type: Copy) {
          from {
            tarTree(configurations."${platform.name}".find { it.name =~ artifactName })
          }
          into "${libDir}/tools"
        }
      }

      task "build${platform.name}"(type: Exec) {
        executable "make"
        args "platform=${platform.operatingSystem.name}",
             "arch=${platform.architecture.name}"
        if(platform.operatingSystem.name == "windows") {
            dependsOn "extract${platform.name}"
            args "win32=${libDir}/tools/win32",
                 "win64=${libDir}/tools/win64"
        }
        environment JAVA_HOME: java_home
      }

      assemble {
        dependsOn "build${platform.name}"
      }
    }
  }
}

tasks.withType(JavaCompile) {
  sourceCompatibility = "1.6"
  targetCompatibility = "1.6"

  options.with {
    encoding = "UTF-8"
    bootClasspath = sourceSets.main.output.classesDir
  }
}

sourceSets {
  main {
    java {
      srcDir 'classpath'
    }
  }
}

javadoc {
  title = "Avian v${version} Class Library API"
}

task javadocJar(type: Jar) {
  dependsOn javadoc
  classifier = 'javadoc'
  from {
    javadoc.destinationDir
  }
}

jar {
  baseName "classpath-avian"
}

publishing {
  repositories {
    add(project.repositories."local")
  }

  publications {

    ivy(IvyPublication) {
      from components.java

      artifact(javadocJar)

      artifact("vm.pro") {
        name "vm"
        type "proguard"
        extension "pro"
      }

      module "classpath-avian"
    }

    create("tools-avian-${currentPlatformArch}", IvyPublication) {
      module "tools-avian-${currentPlatformArch}"

      def publishBinSuffix = currentPlatform == "windows" ? "exe" : "bin"
      def binSuffix = currentPlatform == "windows" ? ".exe" : ""
      artifact("${buildDir}/${currentPlatform}-${currentArch}/binaryToObject/binaryToObject") {
        name "binaryToObject"
        type publishBinSuffix
        extension binSuffix
      }
    }

    platforms.each { platform ->
      def binSuffix=""
      def publishBinSuffix="bin"

      create(platform.name, IvyPublication) {
        def nativeBuildDir = "${buildDir}/${platform.operatingSystem.name}-${platform.architecture.name}"

        if(platform.operatingSystem.name == "windows") {
          publishBinSuffix = "exe"
          binSuffix = ".${publishBinSuffix}"
        }

        module "runtime-avian-${platform.name}"

        artifact("${nativeBuildDir}/avian${binSuffix}") {
          name "avian"
          type publishBinSuffix
          extension publishBinSuffix
        }

        artifact("${nativeBuildDir}/libavian.a") {
          name "libavian"
          type "a"
          extension "a"
        }
      }
    }
  }
}

artifactoryPublish {
  onlyIf { isMaster || isReleaseBranch }
  dependsOn assemble
}

artifactory {
  contextUrl = "http://oss.jfrog.org"

  resolve {
    repository {
      repoKey = 'libs-releases'
    }
  }

  publish {
    repository {
      repoKey = 'oss-snapshot-local'
      username = System.env.BINTRAY_USER
      password = System.env.BINTRAY_API_KEY
      ivy {
        ivyLayout = "[organisation]/[module]/[revision]/ivy-[revision].xml"
      }
    }

    defaults {
      platforms.each {
        publications it.name
      }
    }
  }
}

bintrayUpload.onlyIf { isReleaseBranch || isReleaseTag }

bintray {
  user = System.env.BINTRAY_USER
  key = System.env.BINTRAY_API_KEY
  dryRun = !isReleaseTag
  pkg {
    name = 'avian'
    userOrg = 'readytalk'
    repo = 'maven'
    desc = """\
           Avian is a lightweight virtual machine and class library designed to 
           provide a useful subset of Java's features, suitable for building 
           self-contained applications.
           """.stripIndent()
    websiteUrl = 'http://oss.readytalk.com/avian/'
    issueTrackerUrl = 'https://github.com/ReadTalk/avian/issues'
    vcsUrl = 'https://github.com/ReadTalk/avian.git'
    licenses = ['ISC']
    labels = ['avian', 'jvm', 'java']
    version.vcsTag = buildEnv.travisTag
  }
}

task wrapper(type: Wrapper) {
  gradleVersion = '2.1'
}

ci.dependsOn publish

